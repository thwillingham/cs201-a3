func findSet(v) {
    if (v.parent == v) {
        return v;
    } else {
        v.parent = findSet(v.parent);
        return v.parent;
    }
}

ds class
    rootList = doubly-linked list
    methods
        makeSet
        findSet (path compression)
        union (by rank)


program flow:
import file
  -add edges to linked list (if not already in list)
  -add vertices to linked list (if not already in list)
  -heapsort edges, output to array
  -heapsort vertices, output to array
kruskal
  -make set of every vertex
  -traverse edges and update disjoint set accordingly

func bfs(v) {
    color all vertices white;
    v.color = grey;
    var q = new Queue();
    q.enqueue(v);
    while (q.size > 0) {
        u = q.dequeue();
        for each w adj to u {
            if w.color == white {
                w.color = grey;
                q.enqueue(w);
            }
        }
    u.color = black;
    }
}


program flow:
import file
  -add edges to sorted linked list (if not already in list)
  -add vertices to sorted linked list (if not already in list)
  -convert edges to array
  -convert vertices to array
kruskal
  -make set of every vertex
  -traverse edges and update disjoint set accordingly & update adjacency lists for each node.
print graph
  -traverse edges in order looking for anything with rootNode
  -enqueue any edge that meets the criteria
  -dequeue
